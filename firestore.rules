/**
 * # Firestore Security Rules for Concurso Sprint
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership security model. All user-generated content, such as
 * simulated exams, flashcards, and study plans, is private and accessible only by the user who created it.
 * This ensures data privacy and isolation between users. A separate, global collection for questions
 * is made available for read-only access to all authenticated users.
 *
 * ## Data Structure
 * The data is organized hierarchically to reflect ownership. All user-specific data is nested within a
 * top-level `/users/{userId}` collection. This path-based ownership makes authorization checks simple
 * and performant. Publicly accessible data, like the question bank, resides in its own top-level
 * collection (`/questions`) to segregate it from private user data.
 *
 * ## Key Security Decisions
 * - **Default Deny:** All access is denied by default. Rules explicitly grant permissions.
 * - **User Data Privacy:** Users can only access documents under their own `/users/{userId}` path.
 * - **No User Listing:** It is not possible for any client to list all documents in the `/users` collection.
 * - **Read-Only Public Data:** The `/questions` collection is read-only for any signed-in user.
 *   This data is expected to be managed by a trusted backend or admin process, not by end-users.
 * - **Authorization Independence:** Rules rely on data within the document's path or its own fields for
 *   authorization. This avoids slow and costly `get()` or `exists()` calls to other documents.
 * - **Relational Integrity:** On creation, rules validate that the `userId` field inside a document
 *   matches the `userId` in the path, ensuring a consistent ownership link. This link is immutable
 *   and cannot be changed on update.
 *
 * ## Prototyping Mode
 * These rules are in "Prototyping Mode." They strictly enforce *authorization* (who can access what)
 * but are flexible on data *validation* (the shape of the data). This allows for rapid application
 * development without needing to update security rules for every schema change. Only fields critical for
 * authorization (like `userId`) are validated.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the primary function for enforcing user ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to prevent acting on non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a user is creating their own profile document and that
     * the document's internal `id` field matches their auth UID for integrity.
     */
    function isCreatingOwnProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates that a user is updating their own profile and that the
     * `id` field remains unchanged.
     */
    function isUpdatingOwnProfile(userId) {
      return isExistingOwner(userId) && request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that a user is creating a document in their own subcollection
     * and that the document's internal `userId` field correctly points to them.
     */
    function isCreatingOwnSubcollectionDoc(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates that a user is updating a document in their own subcollection
     * and that the ownership link (`userId` field) is not being changed.
     */
    function isUpdatingOwnSubcollectionDoc(userId) {
      return isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
    }


    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user creating their own profile document.
     * @deny (list) An authenticated user trying to list all user profiles.
     * @principle Restricts access to a user's own profile and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingOwnProfile(userId);
      allow update: if isUpdatingOwnProfile(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to the global question bank.
     * @path /questions/{questionId}
     * @allow (get, list) Any authenticated user can read questions.
     * @deny (update, delete) No client can modify the question bank unless they are the owner.
     * @principle Provides public read access for shared data while protecting it from unauthorized client-side writes.
     */
    match /questions/{questionId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isCreatingOwnSubcollectionDoc(request.auth.uid);
      allow update: if isUpdatingOwnSubcollectionDoc(request.auth.uid);
      allow delete: if isExistingOwner(request.auth.uid);
    }
    
    /**
     * @description Controls access to the global question bank. This is an alias for /questions.
     * @path /questoes/{questaoId}
     * @allow (get, list) Any authenticated user can read questions.
     * @deny (update, delete) No client can modify the question bank unless they are the owner.
     * @principle Provides public read access for shared data while protecting it from unauthorized client-side writes.
     */
    match /questoes/{questaoId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isCreatingOwnSubcollectionDoc(request.auth.uid);
      allow update: if isUpdatingOwnSubcollectionDoc(request.auth.uid);
      allow delete: if isExistingOwner(request.auth.uid);
    }

    /**
     * @description Controls access to a user's simulated exams.
     * @path /users/{userId}/simulatedExams/{simulatedExamId}
     * @allow (create) An authenticated user creating an exam for themselves.
     * @deny (get) A user trying to read another user's exam results.
     * @principle Enforces strict document ownership within a user's private data tree.
     */
    match /users/{userId}/simulatedExams/{simulatedExamId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnSubcollectionDoc(userId);
      allow update: if isUpdatingOwnSubcollectionDoc(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's flashcards.
     * @path /users/{userId}/flashcards/{flashcardId}
     * @allow (create, list) An authenticated user creating and listing their own flashcards.
     * @deny (update, delete) A user trying to modify another user's flashcard.
     * @principle Enforces strict document ownership within a user's private data tree.
     */
    match /users/{userId}/flashcards/{flashcardId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnSubcollectionDoc(userId);
      allow update: if isUpdatingOwnSubcollectionDoc(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's study sessions.
     * @path /users/{userId}/studySessions/{studySessionId}
     * @allow (create) An authenticated user creating a study session for themselves.
     * @deny (get) A user trying to read another user's study session data.
     * @principle Enforces strict document ownership within a user's private data tree.
     */
    match /users/{userId}/studySessions/{studySessionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnSubcollectionDoc(userId);
      allow update: if isUpdatingOwnSubcollectionDoc(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's AI-generated study plans.
     * @path /users/{userId}/aiStudyPlans/{aiStudyPlanId}
     * @allow (get, create) An authenticated user creating and reading their own AI study plans.
     * @deny (list) A user trying to list another user's study plans.
     * @principle Enforces strict document ownership within a user's private data tree.
     */
    match /users/{userId}/aiStudyPlans/{aiStudyPlanId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnSubcollectionDoc(userId);
      allow update: if isUpdatingOwnSubcollectionDoc(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}

    